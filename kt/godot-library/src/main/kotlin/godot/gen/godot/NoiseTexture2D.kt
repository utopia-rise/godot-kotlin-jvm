// THIS FILE IS GENERATED! DO NOT EDIT IT MANUALLY!
@file:Suppress("PackageDirectoryMismatch", "unused", "FunctionName", "RedundantModalityModifier",
    "UNCHECKED_CAST", "JoinDeclarationAndAssignment", "USELESS_CAST",
    "RemoveRedundantQualifierName", "NOTHING_TO_INLINE", "NON_FINAL_MEMBER_IN_OBJECT",
    "RedundantVisibilityModifier", "RedundantUnitReturnType", "MemberVisibilityCanBePrivate")

package godot

import godot.`annotation`.GodotBaseType
import godot.core.TypeManager
import godot.core.VariantType.BOOL
import godot.core.VariantType.DOUBLE
import godot.core.VariantType.LONG
import godot.core.VariantType.NIL
import godot.core.VariantType.OBJECT
import godot.core.memory.TransferContext
import godot.util.VoidPtr
import kotlin.Boolean
import kotlin.Double
import kotlin.Float
import kotlin.Int
import kotlin.Suppress
import kotlin.jvm.JvmName

/**
 * Uses the [FastNoiseLite] library or other noise generators to fill the texture data of your
 * desired size. [NoiseTexture2D] can also generate normal map textures.
 * The class uses [Thread]s to generate the texture data internally, so [Texture2D.getImage] may
 * return `null` if the generation process has not completed yet. In that case, you need to wait for
 * the texture to be generated before accessing the image and the generated byte data:
 * [codeblock]
 * var texture = NoiseTexture2D.new()
 * texture.noise = FastNoiseLite.new()
 * await texture.changed
 * var image = texture.get_image()
 * var data = image.get_data()
 * [/codeblock]
 */
@GodotBaseType
public open class NoiseTexture2D : Texture2D() {
  /**
   * Width of the generated texture (in pixels).
   */
  public var width: Int
    @JvmName("getWidth_prop")
    get() = super.getWidth()
    set(`value`) {
      TransferContext.writeArguments(LONG to value.toLong())
      TransferContext.callMethod(rawPtr, MethodBindings.setWidthPtr, NIL)
    }

  /**
   * Height of the generated texture (in pixels).
   */
  public var height: Int
    @JvmName("getHeight_prop")
    get() = super.getHeight()
    set(`value`) {
      TransferContext.writeArguments(LONG to value.toLong())
      TransferContext.callMethod(rawPtr, MethodBindings.setHeightPtr, NIL)
    }

  /**
   * If `true`, inverts the noise texture. White becomes black, black becomes white.
   */
  public var invert: Boolean
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.getInvertPtr, BOOL)
      return (TransferContext.readReturnValue(BOOL, false) as Boolean)
    }
    set(`value`) {
      TransferContext.writeArguments(BOOL to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setInvertPtr, NIL)
    }

  /**
   * Determines whether the noise image is calculated in 3D space. May result in reduced contrast.
   */
  public var in3dSpace: Boolean
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.isIn3dSpacePtr, BOOL)
      return (TransferContext.readReturnValue(BOOL, false) as Boolean)
    }
    set(`value`) {
      TransferContext.writeArguments(BOOL to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setIn3dSpacePtr, NIL)
    }

  /**
   * Determines whether mipmaps are generated for this texture. Enabling this results in less
   * texture aliasing in the distance, at the cost of increasing memory usage by roughly 33&#37; and
   * making the noise texture generation take longer.
   * **Note:** [generateMipmaps] requires mipmap filtering to be enabled on the material using the
   * [NoiseTexture2D] to have an effect.
   */
  public var generateMipmaps: Boolean
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.isGeneratingMipmapsPtr, BOOL)
      return (TransferContext.readReturnValue(BOOL, false) as Boolean)
    }
    set(`value`) {
      TransferContext.writeArguments(BOOL to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setGenerateMipmapsPtr, NIL)
    }

  /**
   * If `true`, a seamless texture is requested from the [Noise] resource.
   * **Note:** Seamless noise textures may take longer to generate and/or can have a lower contrast
   * compared to non-seamless noise depending on the used [Noise] resource. This is because some
   * implementations use higher dimensions for generating seamless noise.
   * **Note:** The default [FastNoiseLite] implementation uses the fallback path for seamless
   * generation. If using a [width] or [height] lower than the default, you may need to increase
   * [seamlessBlendSkirt] to make seamless blending more effective.
   */
  public var seamless: Boolean
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.getSeamlessPtr, BOOL)
      return (TransferContext.readReturnValue(BOOL, false) as Boolean)
    }
    set(`value`) {
      TransferContext.writeArguments(BOOL to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setSeamlessPtr, NIL)
    }

  /**
   * Used for the default/fallback implementation of the seamless texture generation. It determines
   * the distance over which the seams are blended. High values may result in less details and
   * contrast. See [Noise] for further details.
   * **Note:** If using a [width] or [height] lower than the default, you may need to increase
   * [seamlessBlendSkirt] to make seamless blending more effective.
   */
  public var seamlessBlendSkirt: Float
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.getSeamlessBlendSkirtPtr, DOUBLE)
      return (TransferContext.readReturnValue(DOUBLE, false) as Double).toFloat()
    }
    set(`value`) {
      TransferContext.writeArguments(DOUBLE to value.toDouble())
      TransferContext.callMethod(rawPtr, MethodBindings.setSeamlessBlendSkirtPtr, NIL)
    }

  /**
   * If `true`, the resulting texture contains a normal map created from the original noise
   * interpreted as a bump map.
   */
  public var asNormalMap: Boolean
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.isNormalMapPtr, BOOL)
      return (TransferContext.readReturnValue(BOOL, false) as Boolean)
    }
    set(`value`) {
      TransferContext.writeArguments(BOOL to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setAsNormalMapPtr, NIL)
    }

  /**
   * Strength of the bump maps used in this texture. A higher value will make the bump maps appear
   * larger while a lower value will make them appear softer.
   */
  public var bumpStrength: Float
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.getBumpStrengthPtr, DOUBLE)
      return (TransferContext.readReturnValue(DOUBLE, false) as Double).toFloat()
    }
    set(`value`) {
      TransferContext.writeArguments(DOUBLE to value.toDouble())
      TransferContext.callMethod(rawPtr, MethodBindings.setBumpStrengthPtr, NIL)
    }

  /**
   * If `true`, the noise image coming from the noise generator is normalized to the range `0.0` to
   * `1.0`.
   * Turning normalization off can affect the contrast and allows you to generate non repeating
   * tileable noise textures.
   */
  public var normalize: Boolean
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.isNormalizedPtr, BOOL)
      return (TransferContext.readReturnValue(BOOL, false) as Boolean)
    }
    set(`value`) {
      TransferContext.writeArguments(BOOL to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setNormalizePtr, NIL)
    }

  /**
   * A [Gradient] which is used to map the luminance of each pixel to a color value.
   */
  public var colorRamp: Gradient?
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.getColorRampPtr, OBJECT)
      return (TransferContext.readReturnValue(OBJECT, true) as Gradient?)
    }
    set(`value`) {
      TransferContext.writeArguments(OBJECT to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setColorRampPtr, NIL)
    }

  /**
   * The instance of the [Noise] object.
   */
  public var noise: Noise?
    get() {
      TransferContext.writeArguments()
      TransferContext.callMethod(rawPtr, MethodBindings.getNoisePtr, OBJECT)
      return (TransferContext.readReturnValue(OBJECT, true) as Noise?)
    }
    set(`value`) {
      TransferContext.writeArguments(OBJECT to value)
      TransferContext.callMethod(rawPtr, MethodBindings.setNoisePtr, NIL)
    }

  public override fun new(scriptIndex: Int): Boolean {
    callConstructor(ENGINECLASS_NOISETEXTURE2D, scriptIndex)
    return true
  }

  public companion object

  internal object MethodBindings {
    public val setWidthPtr: VoidPtr = TypeManager.getMethodBindPtr("NoiseTexture2D", "set_width")

    public val setHeightPtr: VoidPtr = TypeManager.getMethodBindPtr("NoiseTexture2D", "set_height")

    public val setInvertPtr: VoidPtr = TypeManager.getMethodBindPtr("NoiseTexture2D", "set_invert")

    public val getInvertPtr: VoidPtr = TypeManager.getMethodBindPtr("NoiseTexture2D", "get_invert")

    public val setIn3dSpacePtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_in_3d_space")

    public val isIn3dSpacePtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "is_in_3d_space")

    public val setGenerateMipmapsPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_generate_mipmaps")

    public val isGeneratingMipmapsPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "is_generating_mipmaps")

    public val setSeamlessPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_seamless")

    public val getSeamlessPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "get_seamless")

    public val setSeamlessBlendSkirtPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_seamless_blend_skirt")

    public val getSeamlessBlendSkirtPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "get_seamless_blend_skirt")

    public val setAsNormalMapPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_as_normal_map")

    public val isNormalMapPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "is_normal_map")

    public val setBumpStrengthPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_bump_strength")

    public val getBumpStrengthPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "get_bump_strength")

    public val setNormalizePtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_normalize")

    public val isNormalizedPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "is_normalized")

    public val setColorRampPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "set_color_ramp")

    public val getColorRampPtr: VoidPtr =
        TypeManager.getMethodBindPtr("NoiseTexture2D", "get_color_ramp")

    public val setNoisePtr: VoidPtr = TypeManager.getMethodBindPtr("NoiseTexture2D", "set_noise")

    public val getNoisePtr: VoidPtr = TypeManager.getMethodBindPtr("NoiseTexture2D", "get_noise")
  }
}
