#include "gdj_language.h"

#include "api/script/jvm_script_manager.h"
#include "api/script/language/gdj_script.h"
#include "godot_jvm.h"
#include "jvm/wrapper/memory/memory_manager.h"
#include "names.h"
#include "paths.h"

using namespace godot;

constexpr const char* GDJ_TEMPLATE = "// GENERATED BY THE GODOT EDITOR. DON'T FORGET TO CREATE A CORRESPONDING SOURCE "
                                     "FILE! OTHERWISE THIS FILE WILL BE DELETED UPON NEXT BUILD.\n"
                                     "\n"
                                     "registeredName = " CLASS_TEMPLATE "\n"
                                     "fqName = " GODOT_KOTLIN_PACKAGE "." CLASS_TEMPLATE "\n"
                                     "relativeSourcePath = \"\"\n"
                                     "baseType = " BASE_TEMPLATE "\n"
                                     "supertypes = [\n"
                                     "    godot." BASE_TEMPLATE "\n"
                                     "]\n"
                                     "signals = []\n"
                                     "properties = []\n"
                                     "functions = []\n";

GdjLanguage* GdjLanguage::get_instance() {
    static GdjLanguage* instance {memnew(GdjLanguage)};
    return instance;
}

void GdjLanguage::_init() {
    GodotJvm::get_instance().initialize_up_to(GodotJvm::State::JVM_SCRIPTS_INITIALIZED);

#ifdef DEBUG_ENABLED
    GodotJvm::get_instance().validate_state();
#endif
}

void GdjLanguage::_frame() {
    if (unlikely(GodotJvm::get_instance().state < GodotJvm::State::CORE_LIBRARY_INITIALIZED)) { return; }
    if (unlikely(GodotJvm::get_instance().user_configuration.disable_gc)) { return; }

    jni::Env env {jni::Jvm::current_env()};
    MemoryManager::get_instance().sync_memory(env);
}

void GdjLanguage::_finish() {
    GodotJvm::get_instance().finalize_down_to(GodotJvm::State::NOT_STARTED);
}

void GdjLanguage::_thread_enter() {
    jni::Jvm::attach();
}

void GdjLanguage::_thread_exit() {
    jni::Jvm::detach();
}

String GdjLanguage::_get_name() const {
    return GODOT_JVM_LANGUAGE_NAME;
}

String GdjLanguage::_get_type() const {
    return GODOT_JVM_SCRIPT_NAME;
}

String GdjLanguage::_get_extension() const {
    return GODOT_JVM_REGISTRATION_FILE_EXTENSION;
}

PackedStringArray GdjLanguage::_get_recognized_extensions() const {
    PackedStringArray ret;
    ret.append(GODOT_JVM_REGISTRATION_FILE_EXTENSION);
    return ret;
}

bool GdjLanguage::_handles_global_class_type(const String& p_type) const {
    return p_type == GODOT_JVM_SCRIPT_NAME;
}

bool GdjLanguage::_has_named_classes() const {
    return true;
}

Object* GdjLanguage::_create_script() const {
    return memnew(GdjScript);
}

Dictionary GdjLanguage::_get_global_class_name(const String& p_path) const {
    Dictionary ret;
    if (p_path.begins_with(ENTRY_DIRECTORY) || !p_path.ends_with(GODOT_JVM_REGISTRATION_FILE_EXTENSION)) {
        return ret;
    }

    ret["is_abstract"] = false;
    ret["is_tool"] = false;

    String script_name = JvmScript::get_script_file_name(p_path);
    Ref<NamedScript> named_script = JvmScriptManager::get_instance()->get_script_from_name(script_name);
    if (!named_script.is_null() && named_script.is_valid()) {
        ret["base_type"] = named_script->get_base_script().is_null()
                           ? named_script->get_instance_base_type()
                           : named_script->get_base_script()->get_global_name();
        ret["name"] = named_script->get_global_name();
    }

    return ret;
}

PackedStringArray GdjLanguage::_get_reserved_words() const {
    static PackedStringArray reserved_words {
      "registeredName",
      "fqName",
      "relativeSourcePath ",
      "baseType ",
      "supertypes",
      "signals",
      "properties",
      "functions"
    };
    return reserved_words;
}

bool GdjLanguage::_is_control_flow_keyword(const String& p_keyword) const {
    return false;
}

PackedStringArray GdjLanguage::_get_comment_delimiters() const {
    static PackedStringArray delimiters {
      "//"
    };
    return delimiters;
}

Vector<String> GdjLanguage::get_doc_comment_delimiters() const {return {};}

Vector<String> GdjLanguage::get_string_delimiters() const {return {};}

Ref<Script> GdjLanguage::make_template(const String& p_template, const String& p_class_name, const String& p_base_class_name) const {
    Ref<GdjScript> gdj_script;
    gdj_script.instantiate();
    String processed_template {
      String(GDJ_TEMPLATE).replace(BASE_TEMPLATE, p_base_class_name).replace(CLASS_TEMPLATE, p_class_name.to_pascal_case())
    };
    gdj_script->set_source_code(processed_template);
    gdj_script->set_name(p_class_name);
    return gdj_script;
}